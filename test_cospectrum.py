"""
test_cospectrum.py
parasynchrony
Brandon Mechtley 2014
Reuman Lab, Kansas Biological Survey

This utility is used to test the symbolic result for cross-spectra produced by
models.py by simulating data out to various numbers of timesteps and comparing
spectral estimates with the analytic result.

Usage:
python convergence.py {run, ploterrors, plotseries, plotcomplex, plotspectra}
    [arg] [config]

    where [config] is a JSON configuration file.

The JSON configuration files are formatted as follows:
{
    "simulation": {
        "model": // model string, given to models.Parasitism.get_model()
        "params": {} // parameters for the model.
        "timesteps": // number of timesteps to simulate.
        "noise": // covariance for model's stochastic terms
    },
    "analysis": {
        "smoothing": {} // parameters for models.smooth for spectral estimation
        "csd": {} // cross-spectra options given to mlab.csd
    }
}

[PyBatchDict](http://github.com/plant/pybatchdict) is used to specify multiple
runs with, e.g. different CSD window sizes. See convergence/nbd2/config.json
and convergence/ar1/config.json for examples.

Commands:
    run: Simulate the model and compute all spectra. Saves pickle files with
        all results in the same directory as the configuration file. Use this
        first to simulate the model, and then use the following commands to
        plot results.
    ploterrors: Plot mean squared error in magnitude and phase of spectra for
        each combination of model state variables.
    plotseries: Plot phase-space combinations of model state variables.
    plotcomplex: Plot cross-spectra as 2D scatter plots in the complex plane.
        If "separate" is specified for [arg], each different configuration
        in the list of configs provided by pybatchdict will be drawn separately
        with color indicating timestep. Otherwise, plots will be overlaid,
        and color will be associated with the order of the configuration (e.g.
        NFFT)
    plotspectra: Plot cross-spectra as magnitude/phase panes. If "separate"
        is specified for [arg], each different configuration will be drawn
        separately. Otherwise, plots will be overlaid and color associated with
        order of the configuration.
"""

import sys
import os
import os.path
import cPickle
from itertools import combinations_with_replacement, izip

import numpy as np
import matplotlib.pyplot as pp
import matplotlib.cm

import pybatchdict as pbdict

import utilities
import models


def spectra_paths(srcfile):
    """
    Return a list of paths to the pickle files generated by run_config() from
    srcfile.

    :param srcfile: path to the pybatchdict configuration JSON.
    :return: (dict, BatchDict): Dictionary containing each configuration, keyed
        by the hyphenated configuration name, where each configuration also
        has a key 'path' that denotes its file path. The BatchDict is from the
        original JSON configuration.
    """

    config = utilities.load_config(srcfile)
    dirname = os.path.dirname(srcfile)
    configurations = dict(zip(config.hyphenate_changes(), config.combos))
    for cname in configurations:
        configurations[cname]['path'] = os.path.join(
            dirname, 'spectra-%s.pickle' % cname
        )

    return configurations, config


def load_spectra(srcfile):
    """
    Load cross-spectra generated by run_config() from srcfile. Each
    configuration's cross-spectra are in a unique pickle file, which are loaded
    and combined in a dict.

    :param srcfile: path to the pybatchdict configuration JSON.
    :return (dict, BatchDict): The dictionary is keyed by the unique identifier
        for the configuration run (from BatchDict.hyphenate_changes()). The
        BatchDict is from the original JSON configuration.
    """

    configurations, config = spectra_paths(srcfile)

    for cname in configurations:
        configurations[cname]['file'] = cPickle.load(
            configurations[cname]['path']
        )

    return configurations, config


def plot_series(picklefile):
    """
    Plot the simulated time series as a collection of phase space 2D histograms
    for each combination of model state variables.

    :param picklefile (str): path to the pickled time series saved by
        run_config().
    """

    series = cPickle.load(open(picklefile, 'r'))

    for run, ls in izip(['linear', 'nonlinear'], [False, True]):
        pp.figure(figsize=(15, 15))

        models.plotting.plot_phase(
            series[run],
            varnames='H_1 H_2 P_1 P_2'.split(),
            logscale=ls,
            plotfun=pp.hist2d,
            bins=400,
            cmap='gist_earth_r'
        )

        pp.savefig(os.path.join(os.path.dirname(picklefile), '%s.png' % run))


def plot_complex(srcfile, separate=False):
    """
    Plot the raw periodogram cross-spectra for the simulations as scatterplots
    on the complex plane.

    :param srcfile (str): path to pybatchdict JSON configuration
    :param separate (bool): whether to draw plots separately or overlaid. If
        separate, data points will be colored according to increasing
        frequency. If overlaid, data points will be uniformly colored according
        to NFFT.
    """

    # Load the spectra computed from run_config().
    print 'Loading spectra.'

    dirname = os.path.dirname(srcfile)
    runs, config = load_spectra(srcfile)

    # Sort the spectra by NFFT.
    runs = sorted(
        runs.values(),
        lambda r1, r2: len(r1['freqs']) - len(r2['freqs'])
    )[::-1]

    nvars = len(runs[0]['model'].vars)
    analytic = None

    specnames = [sn for sn in runs[0]['spectra'].keys() if sn != 'analytic']

    # Plot the cross-spectra in the complex plane.
    print 'Plotting spectra.'

    for specname in specnames:
        print '\tPlotting %s.' % specname
        for r, run in enumerate(runs):
            print '\t\tPlotting run %d (%d bins).' % (
                r,
                run['spectra']['analytic'].shape[2]
            )

            # Make a new figure if plotting separately or this is the first run.
            if separate or r == 0:
                pp.figure(figsize=(15, 15))
                analytic = run['spectra']['analytic']

            # If plotting separately, color according to frequency, otherwise
            # color uniformly according to NFFT.
            if separate:
                color = matplotlib.cm.rainbow(
                    np.linspace(0, 1, len(run['freqs']))
                )
            else:
                color = matplotlib.cm.rainbow(float(r) / len(runs))

            sreal = np.real(run['spectra'][specname])
            simag = np.imag(run['spectra'][specname])

            # Plot each cross-spectral component in a lower-left triangular
            # grid.
            for i, j in combinations_with_replacement(range(nvars), 2):
                pp.subplot(nvars, nvars, nvars * j + i + 1)
                sx, sy = sreal[i, j, :], simag[i, j, :]
                pp.scatter(sx, sy, color=color, marker='.', s=1, alpha=0.125)

                # If this is the last run, plot the analytic cross-spectrum
                # as a solid cyan line.
                if r == len(runs) - 1:
                    pp.plot(
                        np.real(analytic[i, j, :]),
                        np.imag(analytic[i, j, :]),
                        color='cyan'
                    )

                # Only plot the 99.9th percentile of data to avoid outliers.
                distx = np.percentile(np.abs(sx), 99.9)
                disty = np.percentile(np.abs(sy), 99.9)

                pp.xlim(-distx, distx)
                pp.ylim(-disty, disty)

            # If plotting separately, save the intermediate figure.
            if separate:
                figpath = os.path.join(
                    dirname,
                    'complex-%s-%s.png' % (specname, run['name'])
                )

                print 'Writing %s.' % figpath
                pp.savefig(figpath)

        # If not plotting separately, save the final, overlaid figure.
        if not separate:
            figpath = os.path.join(dirname, 'complex-%s.png' % specname)
            print 'Writing %s.' % figpath
            pp.savefig(figpath)


def plot_spectra(srcfile, separate=False):
    """
    Plot the smoothed cross-spectra for a series of simulation configurations.

    :param srcfile (str): path to pybatchdict configuration JSON
    :param separate (bool): whether or not to plot different configurations
        separately or in a single plot. If they're in a single plot, they will
        be sorted and colored according to order.
    """

    # Load the spectra computed from run_config().
    print 'Loading spectra.'

    runs, config = load_spectra(srcfile)

    axpanes = None
    runs = sorted(
        runs.values(),
        lambda r1, r2: len(r1['freqs']) - len(r2['freqs'])
    )

    # Plot the spectra.
    print 'Plotting spectra.'
    for i, run in enumerate(runs):
        # Make a new figure if plotting separately or this is the first
        # configuration.
        if separate or i == 0:
            pp.figure(figsize=(15, 15))

        # Color spectrum according to sorted order if plotting overlaid.
        # Linear: red->yellow, nonlinear: blue->cyan.
        v = float(i) / len(runs) if not separate else 1

        colordict = {
            'linear_smoothed': ((1, v, 0), 'y'),
            'nonlinear_smoothed': ((0, v, 1), 'g'),
            'linear_median': ((), 'orange'),
            'nonlinear_median': ((), 'purple')
        }

        # Plot each spectrum type as two-pane mag/phase plots.
        for spec, color in colordict.iteritems():
            axpanes = models.plotting.plot_cospectra(
                run['freqs'],
                run['spectra'][spec],
                axpanes=axpanes,
                color=color[separate],
                alpha=0.125 if separate else 0.25 * v**2,
                plotfun=pp.scatter,
                varnames=run['model'].vars
            )

        # Only plot the analytic result once, for the very last run (i.e.
        # likely the run with the most spectral data points.)
        if i == len(runs) - 1 or separate:
            models.plotting.plot_cospectra(
                run['freqs'],
                run['spectra']['analytic'],
                axpanes=axpanes,
                color='k',
                plotfun=pp.plot,
                varnames=run['model'].vars
            )

        # Save the figure if plotting separately.
        if separate:
            figfile = os.path.join(
                os.path.dirname(srcfile),
                'spectra-smoothed-%s.png' % run['name']
            )
            print 'Writing %s.' % figfile
            pp.savefig(figfile)

    # Save one final figure if plotting overlaid.
    if not separate:
        figfile = os.path.join(os.path.dirname(srcfile), 'spectra-smoothed.png')
        print 'Writing %s.' % figfile
        pp.savefig(figfile)


def plot_errors(srcfile):
    """
    Plot mean squared error (MSE) of the simulated cross spectra with the
    expected analytic result as a function of number of timesteps (NFFT).
    Three plots are computed: "complex", the MSE of the raw complex numbers,
    "mag" the MSE of the magnitudes, and "phase" the smallest positive angle
    between points.

    :param srcfile (str): configuration file (pybatchdict JSON)
    """

    # Load spectra.
    runs, config = spectra_paths(srcfile)

    runs = sorted(
        runs.values(),
        lambda r1, r2: np.subtract(
            *[rn['analysis']['csd']['NFFT'] for rn in r1, r2]
        )
    )

    # Calculate errors for each variable / spectrum type. errors is a dict
    # where each key, complex, mag, and phase corresponds to a dictionary with
    # keys composed of the different spectrum types (e.g. linear, nonlinear,
    # linear_smoothed, nonlinear_smoothed). Each of these keys points to an
    # (N,N,C) array of MSE values, where N is the number of model state
    # variables and C is the number of unique configurations (e.g. number of
    # different NFFT values used.)

    errors = dict(complex=dict(), mag=dict(), phase=dict())

    for i, runspec in enumerate(runs):
        print 'Loading %s.' % runspec['path']

        run = cPickle.load(open(runspec['path']))
        nvars = len(run['model'].vars)

        analytic_spectrum = run['spectra']['analytic']

        # For each type of spectrum, e.g. linear, nonlinear, *_smoothed, ...
        for spectype, spectrum in run['spectra'].iteritems():
            if spectype != 'analytic':
                # Initialize empty MSE matrix.
                for key in ['complex', 'mag', 'phase']:
                    if spectype not in errors[key]:
                        errors[key][spectype] = np.zeros(
                            (len(runs), nvars, nvars)
                        )

                # MSE of raw complex numbers.
                errors['complex'][spectype][i] = np.mean(
                    abs(spectrum - analytic_spectrum)**2, axis=2
                )

                # MSE of magnitudes.
                errors['mag'][spectype][i] = np.mean(
                    abs(abs(spectrum) - abs(analytic_spectrum))**2, axis=2
                )

                # Smallest angle between phasors (not technically MSE).
                dphase = np.angle(spectrum) - np.angle(analytic_spectrum)

                errors['phase'][spectype][i] = np.mean(
                    np.fmod(
                        np.amin([
                            abs(dphase),
                            abs(dphase - 2 * np.pi),
                            abs(dphase + 2 * np.pi),
                        ], axis=0),
                        2 * np.pi
                    ),
                    axis=2
                )

    # Plot the errors.

    # log-2 NFFT values (e.g. 2**10, 2**11, etc.)
    nfftlog2s = np.log2(np.array([r['analysis']['csd']['NFFT'] for r in runs]))

    # Make the plot.
    # TODO: @ This plot is pretty ugly and has misleading/confusing labels.

    plotargs = dict(
        linear=dict(color='r', ls='-', label='linear'),
        linear_smoothed=dict(color='r', ls='--', label='linear smoothed'),
        linear_median=dict(color='r', ls=':', label='linear median'),
        nonlinear=dict(color='gray', ls='-', label='nonlinear'),
        nonlinear_smoothed=dict(
            color='gray', ls='--', label='nonlinear smoothed'
        ),
        nonlinear_median=dict(color='gray', ls=':', label='nonlinear median')
    )

    xlabels = dict(
        phase='$ME(\\angle \\hat{f}_{xy}, \\angle f_{xy})$',
        mag='$\\log MSE(|\\hat{f}_{xy}|, |f_{xy}|)$',
        complex='$\\log MSE(\\hat{f}_{xy}, f_{xy})$',
    )

    for errortype in errors:
        figfile = os.path.join(
            os.path.dirname(srcfile), 'errors-%s.pdf' % errortype
        )

        print 'Plotting %s.' % figfile

        pp.figure(figsize=(20, 20))

        for spectype in sorted(errors[errortype].keys()):
            print '\tPlotting %s: %s.' % (errortype, spectype)

            for i, j in combinations_with_replacement(range(nvars), 2):
                pp.subplot(nvars, nvars, j * nvars + i + 1)
                pp.plot(
                    nfftlog2s,
                    errors[errortype][spectype][:, i, j],
                    **plotargs[spectype]
                )

                pp.xlabel(xlabels[errortype])
                pp.xlim(np.amin(nfftlog2s), np.amax(nfftlog2s))

                if errortype != 'phase':
                    pp.yscale('log')

        lastax = pp.gca()
        pp.subplot(nvars, nvars, nvars)
        pp.legend(*lastax.get_legend_handles_labels())
        pp.axis('off')

        pp.subplots_adjust(wspace=0.5, hspace=1.0)

        pp.savefig(figfile)


def run_config(srcfile, forceseries=False, forcespectra=False):
    """
    Simulate the model specified in srcfile (a JSON config) and compute its
    cross-spectra. Save results in pickle files in the same directory as
    srcfile.

    :param srcfile (str): path to JSON configuration file.
    """

    # Load each configuration specified by the pybatchdict JSON config.
    configs = utilities.load_config(srcfile)
    seriescache = {}

    for config, cname in izip(configs.combos, configs.hyphenate_changes()):
        print 'Running %s.' % cname

        # Symbol substitution for parameters.
        sym_params = {
            models.parasitism.params[name]: value for name, value in
            pbdict.getkeypath(config, '/simulation/params').iteritems()
        }

        # Simulate time series. Cache time series to avoid re-simulating for
        # the same parameter values.
        model = models.parasitism.get_model(
            pbdict.getkeypath(config, '/simulation/model')
        )

        nvars = len(model.vars)

        # If we don't actually change the simulation, just use the same series
        # each time.
        serieshash = cname if 'simulation' in cname else 1

        seriescache.setdefault(serieshash, {})
        series = seriescache[serieshash]

        noise = np.array(pbdict.getkeypath(
            config, '/simulation/noise'
        ))

        nsteps = pbdict.getkeypath(config, '/simulation/timesteps')

        # If we haven't already simulated for these parameters, do so.
        if 'linear' not in series or 'nonlinear' not in series:
            # Output file for simulation.
            outfile = os.path.join(
                os.path.dirname(srcfile),
                'series-%s.pickle' % cname
            )

            if forceseries or not os.path.exists(outfile):
                # Simulate time series for linearized model.
                if 'linear' not in series:
                    print '\tSimulating linear model (%d steps).' % nsteps

                    series['linear'] = model.simulate_linear(
                        np.zeros(nvars),
                        sym_params,
                        noise,
                        nsteps
                    )

                # Simulate time series for original model.
                if 'nonlinear' not in series:
                    print '\tSimulating nonlinear model (%d steps).' % nsteps

                    series['nonlinear'] = model.simulate(
                        np.array([
                            model.equilibrium[v].subs(sym_params)
                            for v in model.vars
                        ]),
                        sym_params,
                        noise,
                        nsteps
                    )

                print '\tWriting %s.' % outfile
                cPickle.dump(series, open(outfile, 'w'))
            else:
                # If the series has already been simulated and saved, just
                # load it and use it for subsequent cross-spectra computations.

                print '\tLoading saved %s.' % outfile
                loadseries = cPickle.load(open(outfile, 'r'))
                series['linear'] = loadseries['linear']
                series['nonlinear'] = loadseries['nonlinear']

        # Output pickle file for cross-spectra (analytic and estimation from
        # simulated time series).
        outfile = os.path.join(
            os.path.dirname(srcfile),
            'spectra-%s.pickle' % cname
        )

        if forcespectra or not os.path.exists(outfile):
            # Calculate spectral matrices.
            spectra = {}

            csdargs = pbdict.getkeypath(config, '/analysis/csd')
            smoothingargs = pbdict.getkeypath(config, '/analysis/smoothing')

            linear = series['linear']
            nonlinear = series['nonlinear']

            # If we have more time series data than required by our NFFT window
            # size, only use the last NFFT data points rather than using
            # Welch's method to average over periodograms. Done to simplify
            # spectral estimation using smoothing instead. The LAST NFFT data
            # points are used in order to ensure the data are sufficiently
            # random (which they won't be if NFFT=len(linear), since the
            # nonlinear time series always starts at the equilibrium and the
            # linear time series always starts at zero.
            if 'NFFT' in csdargs and csdargs['NFFT'] < linear.shape[1]:
                linear = linear[:, -csdargs['NFFT']:]
                nonlinear = nonlinear[:, -csdargs['NFFT']:]

            # Compute cross-spectra.
            freqs, spectra['linear'] = models.utilities.spectrum(
                linear, **csdargs
            )

            _, spectra['nonlinear'] = models.utilities.spectrum(
                nonlinear, **csdargs
            )

            # Smooth spectral matrices for better estimate.
            # TODO: @ I'm explicitly doing the median filter here. Probably
            # TODO:     better to just define multiple smoothing windows in the
            # TODO:     config dictionary . . .

            spectra['linear_smoothed'] = np.empty_like(spectra['linear'])
            spectra['nonlinear_smoothed'] = np.empty_like(spectra['nonlinear'])
            spectra['linear_median'] = np.empty_like(spectra['linear'])
            spectra['nonlinear_median'] = np.empty_like(spectra['nonlinear'])

            magargs = dict(smoothingargs.iteritems())
            magargs['window'] = 'median'

            for i, j in combinations_with_replacement(range(nvars), 2):
                spectra['linear_smoothed'][i, j] = models.utilities.smooth(
                    spectra['linear'][i, j], **smoothingargs
                )

                spectra['nonlinear_smoothed'][i, j] = models.utilities.smooth(
                    spectra['nonlinear'][i, j], **smoothingargs
                )

                spectra['linear_median'][i, j] = models.utilities.smooth_phasors(
                    spectra['linear'][i, j],
                    magargs=magargs,
                    phasorargs=smoothingargs
                )

                spectra['nonlinear_median'][i, j] = models.utilities.smooth_phasors(
                    spectra['nonlinear'][i, j],
                    magargs=magargs,
                    phasorargs=smoothingargs
                )

            # Evaluate analytic spectral matrix.
            spectra['analytic'] = np.array([
                model.calculate_spectrum(sym_params, noise, v)
                for v in freqs
            ]).T

            if len(spectra['analytic'].shape) == 1:
                spectra['analytic'] = spectra['analytic'].reshape(
                    spectra['linear'].shape
                )

            # Save everything.
            print '\tWriting %s.' % outfile

            cPickle.dump(
                dict(
                    config=config,
                    name=cname,
                    spectra=spectra,
                    freqs=freqs,
                    model=model
                ),
                open(outfile, 'w')
            )
        else:
            print '\tSkipping %s (already exists).' % outfile


def main():
    if len(sys.argv) > 2:
        if sys.argv[1] == 'run':
            run_config(
                sys.argv[-1],
                '--force_series' in sys.argv,
                '--force_spectra' in sys.argv
            )
        elif sys.argv[1] == 'ploterrors':
            plot_errors(sys.argv[-1])
        elif sys.argv[1] == 'plotseries':
            plot_series(sys.argv[-1])
        elif sys.argv[1] == 'plotcomplex':
            plot_complex(sys.argv[-1], '--separate' in sys.argv)
        elif sys.argv[1] == 'plotspectra':
            plot_spectra(sys.argv[-1], '--separate' in sys.argv)

    else:
        print 'usage: python run_convergence.py ' \
            '{run, ploterrors, plotseries, plotspectra} [filename]'

if __name__ == '__main__':
    main()
